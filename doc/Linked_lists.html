

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linked Lists &mdash; decipher 0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="decipher 0.1 documentation" href="../index.html"/>
        <link rel="next" title="Class composition" href="Class_composition.html"/>
        <link rel="prev" title="Pointers" href="Pointers.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> decipher</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Abstract_Data_Types.html">Abstract Data Types (ADT)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Abstract_Data_Types.html#data-structure">1) Data Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="Abstract_Data_Types.html#algorithm">2) Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="Abstract_Data_Types.html#interface">3) Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Constructors.html">Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="Destructors.html">Destructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pointers.html">Pointers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Pointers.html#void-pointers">Void Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="Pointers.html#fuction-pointers">Fuction Pointers</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linked Lists</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#doubly-linked-lists">Doubly-linked Lists</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Class_composition.html">Class composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="Headers.html">Header Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="Copy_Constructors.html">Copy Constructors and Assignment Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="Queues.html">Queues</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Queues.html#algorithm">Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="Queues.html#data-structures">Data structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="Queues.html#interface">Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Stacks.html">Stacks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Stacks.html#infix-and-postfix-expressions">Infix and Postfix expressions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Inheritance.html">Inheritance</a></li>
<li class="toctree-l1"><a class="reference internal" href="Polymorphism.html">Polymorphism</a></li>
<li class="toctree-l1"><a class="reference internal" href="Virtual_fucntions.html">Virtual functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Virtual_fucntions.html#character">Character()</a></li>
<li class="toctree-l2"><a class="reference internal" href="Virtual_fucntions.html#name">name()</a></li>
<li class="toctree-l2"><a class="reference internal" href="Virtual_fucntions.html#printweapon">printWeapon()</a></li>
<li class="toctree-l2"><a class="reference internal" href="Virtual_fucntions.html#attackaction">attackAction()</a></li>
<li class="toctree-l2"><a class="reference internal" href="Virtual_fucntions.html#id21">~Character()</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Generic_Programming.html">Generic programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="Templates.html">Templates</a></li>
<li class="toctree-l1"><a class="reference internal" href="Standard_Template_Classes.html">Standard Template Library (STL) Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Standard_Template_Classes.html#vectors">Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard_Template_Classes.html#lists">Lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard_Template_Classes.html#maps">Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="Standard_Template_Classes.html#sets">Sets</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Recursion.html">Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="Quicksort.html">Quicksort</a></li>
<li class="toctree-l1"><a class="reference internal" href="Big-O.html">Algorithm Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="HashTables.html">Hash Tables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="HashTables.html#closed-hash-table">Closed Hash Table</a></li>
<li class="toctree-l2"><a class="reference internal" href="HashTables.html#open-hash-table">Open Hash Table</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="BinaryTrees.html">Binary Trees</a><ul>
<li class="toctree-l2"><a class="reference internal" href="BinaryTrees.html#traversals">Traversals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="BinarySearchTrees.html">Binary Search Trees (BST)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Unordered_map.html">Unordered map</a></li>
<li class="toctree-l1"><a class="reference internal" href="Heap.html">Heap</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Heap.html#extracting-the-biggest-item-from-a-maxheap-smallest-item-from-a-minheap">Extracting the biggest item from a maxheap (smallest item from a minheap)</a></li>
<li class="toctree-l2"><a class="reference internal" href="Heap.html#adding-a-node-to-a-maxheap-minheap-reheapification">Adding a node to a maxheap/minheap (reheapification)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Priority_queue.html">Priority queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="Heapsort.html">Heapsort</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Heapsort.html#step-1">Step 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="Heapsort.html#step-2">Step 2</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Tables.html">Tables</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">decipher</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Linked Lists</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../_sources/doc/Linked_lists.rst.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="linked-lists">
<h1>Linked Lists<a class="headerlink" href="#linked-lists" title="Permalink to this headline">¶</a></h1>
<p>Recall from the first email about ADTs that every ADT has a data structure, algorithm, and interface.
In this email I will be talking about a linked list, which is a type of data structure.</p>
<p>A linked list is like an array except every element consists of dynamically-allocated variable and pointer; this is called a node.
Unlike an array, the nodes aren’t next to each other in memory, instead they are scattered randomly through out memory.
How are the connected? Every node’s pointer points to the next one.
The list starts with a head pointer that points to first node, and the list ends with the last node pointing to null pointer.
Here is what the code looks like.</p>
<p>First things first, let’s create a struct for the items we want to store.
This struct will be the type for the node.
Remember that every node needs some amount of variables and a pointer of type struct.
In this example we will only have two variables, but you can have as many and with whatever types you want.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Scientist</span>
<span class="p">{</span>
     <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
     <span class="n">string</span> <span class="n">field</span><span class="p">;</span>
     <span class="n">Scientist</span><span class="o">*</span> <span class="n">foo</span><span class="p">;</span>     <span class="c1">// foo will point to the next Scientist item</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Why is the pointer of the same type as the struct itself?
The pointer needs to be able to hold the address of another struct of the same kind. It is NOT pointing to itself.</p>
<p>Let’s try creating some instances of our struct. First we need to declare a head pointer.
When creating the instances, it is typical to dynamically allocate them. Because of that, we need additional pointers to hold our Scientists instances.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="c1">// Pointers holding the nodes</span>
     <span class="n">Scientist</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scientist</span><span class="p">;</span>
     <span class="n">Scientist</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scientist</span><span class="p">;</span>
     <span class="n">Scientist</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scientist</span><span class="p">;</span>

     <span class="c1">// Assigning the variable and pointer of the first node, pointed to by the head pointer</span>
     <span class="n">head</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Sheldon Cooper&quot;</span><span class="p">;</span>
     <span class="n">head</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="s">&quot;Theoretical physics&quot;</span><span class="p">;</span>
     <span class="n">head</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// Pointer points to the next node, a</span>

     <span class="c1">// a node</span>
     <span class="n">a</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Howard Wolowitz&quot;</span><span class="p">;</span>
     <span class="n">a</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="s">&quot;Engineering&quot;</span><span class="p">;</span>
     <span class="n">a</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// Pointer points to the next node, b</span>

     <span class="c1">// b node</span>
     <span class="n">b</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Amy Farrah Fowler&quot;</span><span class="p">;</span>
     <span class="n">b</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="s">&quot;Neurobiology&quot;</span><span class="p">;</span>
     <span class="n">b</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// Pointer points to nullptr, no more nodes</span>

    <span class="c1">// Be sure to delete the pointers because they are using memory on the heap</span>
     <span class="k">delete</span> <span class="n">head</span><span class="p">;</span>
     <span class="k">delete</span> <span class="n">a</span><span class="p">;</span>
     <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This feels tedious to use main to create our instances.
Why don’t we just create a linked list class?
A linked list class is like a class but with only one member variable: the head pointer.
We can add public functions that can perform basic operations on the linked list.
I’ll go over them in more depth below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Scientist</span>
<span class="p">{</span>
     <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
     <span class="n">string</span> <span class="n">field</span><span class="p">;</span>
     <span class="n">Scientist</span><span class="o">*</span> <span class="n">foo</span><span class="p">;</span>     <span class="c1">// foo will point to the next Scientist item</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">BigBang</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BigBang</span><span class="p">();</span>       <span class="c1">// constructor</span>
    <span class="kt">void</span> <span class="nf">addToFront</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">,</span> <span class="n">string</span> <span class="n">f</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">addToRear</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">,</span> <span class="n">string</span> <span class="n">f</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">deleteScientist</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">findScientist</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">printScientists</span><span class="p">();</span>
    <span class="o">~</span><span class="n">BigBang</span><span class="p">();</span>       <span class="c1">// destructor</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Scientist</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">addScientistToRear</span><span class="p">(</span><span class="s">&quot;Sheldon Cooper&quot;</span><span class="p">,</span> <span class="s">&quot;Theoretical physics&quot;</span><span class="p">);</span>
     <span class="n">addScientistToRear</span><span class="p">(</span><span class="s">&quot;Howard Wolowitz&quot;</span><span class="p">,</span> <span class="s">&quot;Engineering&quot;</span><span class="p">);</span>
     <span class="n">addScientistToRear</span><span class="p">(</span><span class="s">&quot;Amy Farrah Fowler&quot;</span><span class="p">,</span> <span class="s">&quot;Neurobiology&quot;</span><span class="p">);</span>

     <span class="n">deleteScientist</span><span class="p">(</span><span class="s">&quot;Howard Wolowitz&quot;</span><span class="p">);</span>
     <span class="n">findScientist</span><span class="p">(</span><span class="s">&quot;Raj Koothrappali&quot;</span><span class="p">);</span>    <span class="c1">// returns false</span>
     <span class="n">printScientists</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because this is a class, we need a constructor.
The only member variable in the class is head.
We want to initialize it to nullptr because
a) you shouldn’t use a pointer without initializing it because bad things can happen and
b) this also means that we are initializing it to an empty list.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BigBang</span><span class="o">::</span><span class="n">BigBang</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>   <span class="c1">// if head is equal to nullptr, the list is empty</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also write a public function that can add a node depending on where we want it.
Depending on where it is, you have to adjust different pointers and you may or may not have to traverse part or all of the array.
If you were to add an item to an empty list, you could call either function, as addToRear transfers you to addToFront if the list is empty.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">BigBang</span><span class="o">::</span><span class="n">addToFront</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">,</span> <span class="n">string</span> <span class="n">f</span><span class="p">)</span> <span class="c1">// parameters for name and field</span>
<span class="p">{</span>
    <span class="n">Scientist</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scientist</span><span class="p">;</span>  <span class="c1">// Create a new Scientist, node points to it</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>     <span class="c1">// Change the item&#39;s variables through the pointer</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>

    <span class="n">node</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>    <span class="c1">// Sets node equal to the node that the head points to (remember that head still points to the previous top node).</span>

    <span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// Sets head to point to the same node as the temporary one (aka the new top node).</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">BigBang</span><span class="o">::</span><span class="n">addToRear</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">,</span> <span class="n">string</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>   <span class="c1">// if the head points to nullptr, aka empty list</span>
        <span class="n">addToFront</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Scientist</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>  <span class="c1">// create a temporary pointer</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="c1">// while the pointer of the node that the pointer points to is not nullptr, aka while it&#39;s not at the last node</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">;</span>  <span class="c1">// keep on traversing the list through the nodes&#39; pointers</span>
        <span class="n">Scientist</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scientist</span><span class="p">;</span>  <span class="c1">// create new item</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>   <span class="c1">// set variables</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>

        <span class="n">node</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>   <span class="c1">// since this is the last item, its pointer points to nullptr</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice that to avoid going past the last node in the while loop, you need to use (ptr-&gt;foo != nullptr).
This will stop moving the pointer once it reaches the last node.
Quick note: you can NOT use ptr++ to traverse a linked list.
Why?
<code class="docutils literal notranslate"><span class="pre">ptr++</span></code> moves the pointer forward in memory how ever many bytes are in Scientist variable,
and there is NO guarantee that the next node of a linked list is at that memory address.
Remember, this is not an array, so the nodes are not next to one another in memory.</p>
<p>Let’s add a function that traverses the list and prints out every Scientist.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">BigBang</span><span class="o">::</span><span class="n">printScientists</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Scientist</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>    <span class="c1">// temporary pointer, starts out pointing to the same node as head</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>     <span class="c1">// while the pointer isn&#39;t at the end</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Field: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">field</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">;</span>      <span class="c1">// continue traversing</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice here that we’re using (ptr != nullptr), not (ptr-&gt;foo != nullptr).
Why is that?
Here it’s okay to go past the last node because we aren’t looking for it specifically, we just want to print out the values.
The compiler will run through the loop, and once it goes to nullptr, it will say “well, that’s the end of that of the list.
There is nothing else to do.
But in the case of the previous function,
we couldn’t have left the pointer to go to nullptr because by then the pointer would’ve have gone too far and
we wouldn’t be able to backtrack to the previous node.
This is one of the characteristics of linked lists (or at least the form we are looking at now):
going through the list is a one way street and if you want to reach an item at the bottom, you need to go traverse the whole list.</p>
<p>Here’s a function that finds a Scientist (I wrote this one; it’s correct, right?).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">BigBang</span><span class="o">::</span><span class="n">findScientist</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Scientist</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>   <span class="c1">// temporary pointer</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
               <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here’s a function that deletes a Scientist.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">BigBang</span><span class="o">::</span><span class="n">deleteScientist</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Scientist</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>    <span class="c1">// temporary pointer</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>   <span class="c1">// until it&#39;s at the end of the list</span>
    <span class="p">{</span>
<span class="c1">// Stop the loop if the next node isn&#39;t a nullptr and the next node&#39;s name is a match; stop at the node above the selected node</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>     <span class="c1">// Check to make sure it isn&#39;t at the end of the list</span>
        <span class="n">Scientist</span> <span class="o">*</span><span class="n">killMe</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">;</span>   <span class="c1">// another temporary pointer set to target (the next node)</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="n">killMe</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">;</span>  <span class="c1">// previous node is set to point to the node after the node to be deleted.</span>
    <span class="k">delete</span> <span class="n">killMe</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And finally, let’s write the destructor. We need it because the linked list is made up of dynamically allocated variables.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BigBang</span><span class="o">::~</span><span class="n">BigBang</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Scientist</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>   <span class="c1">// temporary pointer set to same node as head</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Scientist</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">;</span>  <span class="c1">// another temporary pointer set to the node after ptr</span>
        <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>  <span class="c1">// the node that ptr points to</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">;</span>   <span class="c1">// ptr now points to the next node</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice here that I am using two pointers to destruct a list.
Why?
If you try to destruct a node with one pointer, you can, but when you try to go to the next node, uh oh!
You’ve deleted the pointer that takes you to the next node. So what you need to do is have another pointer to act like a bookmark, ptr2 in this case.
Place ptr2 at the node after the one you want to delete, so when you want to get to that node, you can get its address from ptr2.</p>
<p>So, is a linked list better than an array? It’s certainly more complicated. However, the linked list data structure allows you to insert, rearrange, and delete a node with more efficiency and speed (overall). However, it lacks the instant access an array gives you.
Let’s see how an array can perform the actions we defined for a linked list by using an array of type BigBang.</p>
<p>ADDING AN ITEM TO THE FRONT</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">BigBang</span> <span class="n">scientists</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
     <span class="n">scientists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scientists</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="n">scientists</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Sheldon Cooper&quot;</span><span class="p">;</span>
<span class="n">scientists</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">field</span> <span class="o">=</span> <span class="s">&quot;Theoretical physics&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>ADDING AN ITEM TO THE REAR</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scientists</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Amy Farrah Fowler&quot;</span><span class="p">;</span>
<span class="n">scientists</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">field</span> <span class="o">=</span> <span class="s">&quot;Neurobiology&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>DELETING AN ITEM</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// Less efficient and slower than linked list</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scientists</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="o">==</span> <span class="n">name</span><span class="p">)</span>
   <span class="p">{</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
             <span class="n">scientists</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">scientists</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
         <span class="k">break</span><span class="p">;</span>
   <span class="p">}</span>
</pre></div>
</div>
<p>FINDING AN ITEM</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scientists</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">)</span>
         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>
</div>
<p>PRINTING ALL ITEMS</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">scientists</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Field: &quot;</span><span class="o">&lt;&lt;</span> <span class="n">scientists</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">field</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="doubly-linked-lists">
<h2>Doubly-linked Lists<a class="headerlink" href="#doubly-linked-lists" title="Permalink to this headline">¶</a></h2>
<p>A doubly-linked list allows you to traverse a linked list both ways (like a two-way street!).
How? By adding another pointer to every node that points to the previous node.
This is a lot more complicated because you need to update three sets of pointers, in this order:
1) The new node’s next and previous pointers.
2) The previous node’s next pointer.
3) The following node’s previous pointer.
Here’s an example of what a node’s stuct will now look like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Scientist</span>
<span class="p">{</span>
     <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
     <span class="n">string</span> <span class="n">field</span><span class="p">;</span>
     <span class="n">Scientist</span><span class="o">*</span> <span class="n">foo</span><span class="p">;</span>     <span class="c1">// foo will point to the next Scientist item</span>
     <span class="n">Scientist</span><span class="o">*</span> <span class="n">bar</span><span class="p">;</span>     <span class="c1">// bar will point to the previous Scientist item</span>
<span class="p">};</span>
</pre></div>
</div>
<p>By the way, the first node’s bar pointer will be set to nullptr, not the head, to indicate the beginning of the array.</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Class_composition.html" class="btn btn-neutral float-right" title="Class composition">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Pointers.html" class="btn btn-neutral" title="Pointers"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, neda vesselinova.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>